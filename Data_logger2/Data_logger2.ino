/* ============================================
*   Motorcycle Data logger sketch by Gideon Nyaga...
*   giddyeffects@gmail.com
*  ===============================================
*/

//==========INCLUDES==========
// for memory storage in program space
#include <avr/pgmspace.h>
//I2C Bus lib
#include "I2Cdev.h"
//include time lib
#include "Time.h"
//include RealTimeClock/RTC lib
#include "DS1307RTC.h"
//load the elasped library
#include <elapsedMillis.h>
//Arduino Wire Library
#include "Wire.h"
//include I2C LCD display libary
#include <LiquidCrystal_I2C.h>

//==========VARIABLES==========
//Init LCD
LiquidCrystal_I2C lcd(0x3F, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE); //=> addr, EN, RW, RS, D4, D5, D6, D7, BacklightPin, POLARITY... Set the LCD I2C address 20x04 screen
//Create an elapsedMillis Instance
elapsedMillis timeElapsed;
//welcome message
char welcomeMsg[] = "HONDA";
char welcomeMsg2[] = "FALCON";
// RTC non-volatile storage
#define RTC_I2C_ADDR 0x68           // Real time clock address on the I2C bus
#define RAM_ADDR 8                  // RTC RAM registers start at address 8
#define TRIPA_ADDR RAM_ADDR         // Trips, ODO, lat and long are all floats, 4 bytes ea.
#define SERVICE_ADDR TRIPA_ADDR + 4 //@TODO can change this to tripmeter B
#define ODO_ADDR SERVICE_ADDR + 4
//#define LAT_ADDR      ODO_ADDR + 4 //tobe activated once i get GPS chip
//#define LON_ADDR      LAT_ADDR + 4 //

//==========PIN ALLOCATION==========
#define INTERRUPT_PIN 2      // use pin 2 on Arduino Uno & most boards
#define HALL_INTERRUPT_PIN 3 //also pin 3 can be used as interrupt
#define LED_PIN 13           //(Arduino is 13, Teensy is 11, Teensy++ is 6)
#define RPM_LED_PIN 11
#define BAT_LED_PIN 10
#define GPS_LED_PIN 9
#define SERVICE_LED_PIN 8
#define BATTERY_PIN A2 //use analog pin2 to read motorbike battery voltage
//define trip meter reset button
#define resetTripBtn 6
//define buttons to operate LCD screen
#define backlightBtn 5 // pushbutton 5 pin
#define goRightBtn 4   // pushbutton 4 pin
#define airTempPin A3  //using analog pin 3 to measure sensor's input SIGNAL

//values to store in NVRAM
float f_TripA = 0.0;
float f_Service = 0.0;
float f_ODO = 0.0;

//==========SPEED & ODO VARIABLES==========
long odometer = 0L;       //odometer internal: 0 to 999,999
float tripmeterA = 0.0;   //tripmeter internal: 0 to 999
float servicemeter = 0.0; //distance since last service...
String bigKPH;
int rotationcounter = 0;

int vspeed = 0;
int dvspeed = 0;
int tyrec = 1935; //tyre circumference in ??
long deltat = 0;
long timea = 0;
long timec = 0;

int speedrr = 500;
const int speedarraysize = 5;
int speedarray[speedarraysize];
int arrayposition = 0;

//==========BATTERY VOLTAGE VARIABES==========
// number of analog samples to take per reading
#define NUM_SAMPLES 10
float battVoltage = 0.0;        //calculated voltage
int vsum = 0;                   //voltage sum of samples taken
unsigned char sample_count = 0; // current sample number

//==========define & init screens==========
byte curScreen = 1;  //current LCD screen
byte maxScreens = 3; //max screens to be shown

//==========define other variables==========
int engRPM = 0; //engine rpm
float airTemp = 0.0;
float engineTemp = 0.0;
bool backlightState = true;

//I2C address of the MPU6050.
const int MPU=0x69;  
const float alpha = 0.955; //Low Pass Filter smoothing factor
int16_t ax,ay,az,gx,gy,gz,airTemp;//was int
double pitch, roll, yaw, fXg=0, fYg=0, fZg=0, timer;
double accXangle ,accYangle,accZangle ,gyroXrate ,gyroYrate,gyroZrate;
double gyroXAngle, gyroYAngle, gyroZAngle;

// ================================================================
// ===               BIG FONT CHARACTER SET                     ===
// ================================================================
const char custom[][8] PROGMEM = {
    // Custom character definitions
    {0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00}, // char 1
    {0x18, 0x1C, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F}, // char 2
    {0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x07, 0x03}, // char 3
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F}, // char 4
    {0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1E, 0x1C, 0x18}, // char 5
    {0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x1F, 0x1F}, // char 6
    {0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F}, // char 7
    {0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F}  // char 8
};
const char bigChars[][8] PROGMEM = {
    {0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Space
    {0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // !
    {0x05, 0x05, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00}, // "
    {0x04, 0xFF, 0x04, 0xFF, 0x04, 0x01, 0xFF, 0x01}, // #
    {0x08, 0xFF, 0x06, 0x07, 0xFF, 0x05, 0x00, 0x00}, // $
    {0x01, 0x20, 0x04, 0x01, 0x04, 0x01, 0x20, 0x04}, // %
    {0x08, 0x06, 0x02, 0x20, 0x03, 0x07, 0x02, 0x04}, // &
    {0x05, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    {0x08, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00}, // (
    {0x01, 0x02, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00}, // )
    {0x01, 0x04, 0x04, 0x01, 0x04, 0x01, 0x01, 0x04}, // *
    {0x04, 0xFF, 0x04, 0x01, 0xFF, 0x01, 0x00, 0x00}, // +
    {0x20, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //
    {0x04, 0x04, 0x04, 0x20, 0x20, 0x20, 0x00, 0x00}, // -
    {0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // .
    {0x20, 0x20, 0x04, 0x01, 0x04, 0x01, 0x20, 0x20}, // /
    {0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00}, // 0
    {0x01, 0x02, 0x20, 0x04, 0xFF, 0x04, 0x00, 0x00}, // 1
    {0x06, 0x06, 0x02, 0xFF, 0x07, 0x07, 0x00, 0x00}, // 2
    {0x01, 0x06, 0x02, 0x04, 0x07, 0x05, 0x00, 0x00}, // 3
    {0x03, 0x04, 0xFF, 0x20, 0x20, 0xFF, 0x00, 0x00}, // 4
    {0xFF, 0x06, 0x06, 0x07, 0x07, 0x05, 0x00, 0x00}, // 5
    {0x08, 0x06, 0x06, 0x03, 0x07, 0x05, 0x00, 0x00}, // 6
    {0x01, 0x01, 0x02, 0x20, 0x08, 0x20, 0x00, 0x00}, // 7
    {0x08, 0x06, 0x02, 0x03, 0x07, 0x05, 0x00, 0x00}, // 8
    {0x08, 0x06, 0x02, 0x07, 0x07, 0x05, 0x00, 0x00}, // 9
    {0xA5, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // :
    {0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ;
    {0x20, 0x04, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00}, // <
    {0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00}, // =
    {0x01, 0x04, 0x20, 0x04, 0x01, 0x01, 0x00, 0x00}, // >
    {0x01, 0x06, 0x02, 0x20, 0x07, 0x20, 0x00, 0x00}, // ?
    {0x08, 0x06, 0x02, 0x03, 0x04, 0x04, 0x00, 0x00}, // @
    {0x08, 0x06, 0x02, 0xFF, 0x20, 0xFF, 0x00, 0x00}, // A
    {0xFF, 0x06, 0x05, 0xFF, 0x07, 0x02, 0x00, 0x00}, // B
    {0x08, 0x01, 0x01, 0x03, 0x04, 0x04, 0x00, 0x00}, // C
    {0xFF, 0x01, 0x02, 0xFF, 0x04, 0x05, 0x00, 0x00}, // D
    {0xFF, 0x06, 0x06, 0xFF, 0x07, 0x07, 0x00, 0x00}, // E
    {0xFF, 0x06, 0x06, 0xFF, 0x20, 0x20, 0x00, 0x00}, // F
    {0x08, 0x01, 0x01, 0x03, 0x04, 0x02, 0x00, 0x00}, // G
    {0xFF, 0x04, 0xFF, 0xFF, 0x20, 0xFF, 0x00, 0x00}, // H
    {0x01, 0xFF, 0x01, 0x04, 0xFF, 0x04, 0x00, 0x00}, // I
    {0x20, 0x20, 0xFF, 0x04, 0x04, 0x05, 0x00, 0x00}, // J
    {0xFF, 0x04, 0x05, 0xFF, 0x20, 0x02, 0x00, 0x00}, // K
    {0xFF, 0x20, 0x20, 0xFF, 0x04, 0x04, 0x00, 0x00}, // L
    {0x08, 0x03, 0x05, 0x02, 0xFF, 0x20, 0x20, 0xFF}, // M
    {0xFF, 0x02, 0x20, 0xFF, 0xFF, 0x20, 0x03, 0xFF}, // N
    {0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00}, // 0
    {0x08, 0x06, 0x02, 0xFF, 0x20, 0x20, 0x00, 0x00}, // P
    {0x08, 0x01, 0x02, 0x20, 0x03, 0x04, 0xFF, 0x04}, // Q
    {0xFF, 0x06, 0x02, 0xFF, 0x20, 0x02, 0x00, 0x00}, // R
    {0x08, 0x06, 0x06, 0x07, 0x07, 0x05, 0x00, 0x00}, // S
    {0x01, 0xFF, 0x01, 0x20, 0xFF, 0x20, 0x00, 0x00}, // T
    {0xFF, 0x20, 0xFF, 0x03, 0x04, 0x05, 0x00, 0x00}, // U
    {0x03, 0x20, 0x20, 0x05, 0x20, 0x02, 0x08, 0x20}, // V
    {0xFF, 0x20, 0x20, 0xFF, 0x03, 0x08, 0x02, 0x05}, // W
    {0x03, 0x04, 0x05, 0x08, 0x20, 0x02, 0x00, 0x00}, // X
    {0x03, 0x04, 0x05, 0x20, 0xFF, 0x20, 0x00, 0x00}, // Y
    {0x01, 0x06, 0x05, 0x08, 0x07, 0x04, 0x00, 0x00}, // Z
    {0xFF, 0x01, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00}, // [
    {0x01, 0x04, 0x20, 0x20, 0x20, 0x20, 0x01, 0x04}, // Backslash
    {0x01, 0xFF, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00}, // ]
    {0x08, 0x02, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00}, // ^
    {0x20, 0x20, 0x20, 0x04, 0x04, 0x04, 0x00, 0x00}  // _
};
byte col, row, nb = 0, bc = 0; // general
byte bb[8];                    // byte buffer for reading from PROGMEM

// ================================================================
// ===               INTERRUPT DETECTION ROUTINE                ===
// ================================================================

//interrupt detection for hall sensor
void magnetDetect()
{ //called whenever a magnet/interrupt is detected by the hall sensor
  vspeed = tyrec * 3.6 / (millis() - deltat);
  timea = millis();
  deltat = millis();
  rotationcounter = rotationcounter + 1;
}

// ================================================================
// ===                      INITIAL SETUP                       ===
// ================================================================
void setup() {

    Serial.begin(115200);
    
    Wire.begin();
    Wire.beginTransmission(MPU);
    Wire.write(0x6B); 
    Wire.write(0); 
    Wire.endTransmission(true);

}

void loop() {
    
    Wire.beginTransmission(MPU);
    Wire.write(0x3B);
    Wire.endTransmission(false);
    
    //Requests the data from the sensor.
    Wire.requestFrom(MPU,14,true);  

  //Read the sensor data.
    ax = Wire.read()<<8|Wire.read();  //0x3B (ACCEL_XOUT_H) & 0x3C (ACCEL_XOUT_L)     
    ay = Wire.read()<<8|Wire.read();  //0x3D (ACCEL_YOUT_H) & 0x3E (ACCEL_YOUT_L)
    az = Wire.read()<<8|Wire.read();  //0x3F (ACCEL_ZOUT_H) & 0x40 (ACCEL_ZOUT_L)
    airTemp = Wire.read()<<8|Wire.read();  //0x41 (TEMP_OUT_H) & 0x42 (TEMP_OUT_L)
    gx = Wire.read()<<8|Wire.read();  //0x43 (GYRO_XOUT_H) & 0x44 (GYRO_XOUT_L)
    gy = Wire.read()<<8|Wire.read();  //0x45 (GYRO_YOUT_H) & 0x46 (GYRO_YOUT_L)
    gz = Wire.read()<<8|Wire.read();  //0x47 (GYRO_ZOUT_H) & 0x48 (GYRO_ZOUT_L)
    
    Serial.println("Raw Values");
    Serial.println("==========");
    Serial.print("ax/ay/az/gx/gy/gz/airTemp\t");
    Serial.print(ax);
    Serial.print("\t");
    Serial.print(ay);
    Serial.print("\t");
    Serial.print(az);
    Serial.print("\t");
    Serial.print(gx);
    Serial.print("\t");
    Serial.print(gy);
    Serial.print("\t");
    Serial.print(gz);
    Serial.print("\t");
    Serial.print(airTemp/340 + 36.53);
    Serial.println();

  accXangle = (atan2(ay, az) * RAD_TO_DEG);
  accYangle = (atan2(ax, az) * RAD_TO_DEG);
  accZangle = (atan2(ax,ay) * RAD_TO_DEG);/* calculate yaw but not correct*/
  gyroXrate = gx / 16.5;
  gyroYrate = gy / 16.5;
  gyroZrate = gz / 16.5;
  timer = millis();
  //angular position
  gyroXAngle += gyroXrate * (millis()-timer)/1000;
  gyroYAngle += gyroYrate * (millis()-timer)/1000;
  gyroZAngle += gyroZrate * (millis()-timer)/1000;/* alculate yaw but not correct*/

  roll = alpha * ( roll + gyroXAngle) + (1-alpha) * accXangle;
  pitch = alpha * (pitch + gyroYAngle) + (1-alpha) * accYangle;
  yaw = alpha * (yaw + gyroZAngle) + (1-alpha) * accZangle; /*yaw but not correct*/
 /* first attempt
    //Low Pass filter
    fXg = gx * alpha + (fXg * (1.0 - alpha));
    fYg = gy * alpha + (fYg * (1.0 - alpha));
    fZg = gz * alpha + (fZg * (1.0 - alpha));

    //Roll & Pitch Equations
    roll  = (atan2(-fYg, fZg)*180.0)/M_PI;
    pitch = (atan2(fXg, sqrt(fYg*fYg + fZg*fZg))*180.0)/M_PI; */
    Serial.print(yaw);
    Serial.print(":");
    Serial.print(pitch);
    Serial.print(":");
    Serial.println(roll);
  delay(100);
    
}
